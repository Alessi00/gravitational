Ⓜ️ main process

⭕️ shared process

⚠️ note


Main issues discussed here:

* PtyServiceClient/PtyHostClient on client.
* No clear mapping between server-side code and client-side code, like we do with tshd gRPC calls.

## Object/function names involved in the whole process

```
packages/teleterm/src/sharedProcess/ptyHost
├── client
│   ├── buildPtyOptions.ts
│   ├── createPtyProcessClient.ts
│   ├── fixtures
│   │   └── mocks.ts
│   ├── index.ts
│   ├── ptyHostClient.ts
│   └── resolveShellEnv.ts
├── index.ts
├── ptyHostService.proto
├── server
│   ├── index.ts
│   ├── ptyEventsStreamHandler.ts
│   ├── ptyHostService.ts
│   └── ptyProcess.ts
├── types.ts
└── v1
    ├── ptyHostService_grpc_pb.d.ts
    ├── ptyHostService_grpc_pb.js
    ├── ptyHostService_pb.d.ts
    └── ptyHostService_pb.js
```

### Setup

* Ⓜ️ (ptyHostClient) createPtyHostClient -> returns PtyServiceClient (object), inject into app context, TerminalsService
  * ⚠️ The only thing that PtyServiceClient does is provide the option to call createPtyProcess,
  perhaps the function should be called `createPtyServiceClient` and not `createPtyHostClient`? And
  the file shouldn't be called PtyHostClient? The actual PtyHostClient is autogenerated from gRPC.
  It makes it seem like server/ptyHostClient.ts is the client-side equivalent of
  server/ptyHostService.ts, which is not true.
  * ⚠️ That's one of the problems, there's no clear mapping between ptyHostService and the client
  side. PtyHostClient is used across many different files, unlike with tshd/createClient.ts, which
  completely wraps tshd and there's an easy mapping between client usage of tshd and the handlers on
  the backend. Or maybe it's just that I'm more used to that part of the code.
    * new PtyHostClient()

* Ⓜ️ MainProcess._initSharedProcess
  * ⭕️ createServer
  * server.addService(PtyHostService, createPtyHostService())
  * createPtyHostService -> IPtyHostServer

### Creating a terminal tab

* Ⓜ️ useDocumentTerminal
* TerminalsService.createPtyProcess
* PtyServiceClient.createPtyProcess
* (ptyHostClient) createPtyProcess
  * PtyHostClient.createPtyProcess
    * ⭕️ (ptyHostService) createPtyProcess
    * new PtyProcess (class)
* Ⓜ️ createPtyProcessClient -> returns PtyProcess (object)
  * ⚠️ should this be named PtyProcessClient?
  * PtyHostClient.exchangeEvents
    * ⭕️ (ptyHostService) exchangeEvents
    * new PtyEventsStreamHandler


## Mapping between server-side code and client-side code

createPtyProcessClient PtyProcess maps to PtyEventsStreamHandler

* ⚠️ Organize the methods on the client side (`createPtyProcessClient`) and the server side
(`PtyEventsStreamHandler`, `ptyHostService`) clearly with comments into three groups: client-server
RPC calls, events that the client sends to the server and events that the server sends to the
client. Currently they're intertwined together.
  * The general structure of the code should be similar between both the client and the server, by
  that I mean mostly the stream handlers. It'd also be super good if naming was consistent between
  client and server, right now I need to know upfront that PtyProcess on the client-side maps to
  PtyEventsStreamHandler on the server side.
    * PtyProcess on client and PtyEventsStreamHandler deal exclusively with the stream, except the
      getCwd RPC.
    * PtyProcess on client is a very useful abstraction though, this is what we want to use on the
      client. However, it's super hard to conceptually map it to ptyHostService.
    * Perhaps PtyProcess on client shouldn't use PtyHostClient directly. Instead, we could introduce
      a layer of abstraction, similar to tshd/createClient.
      * PtyProcess on client could then remain the same, have the same methods, but it'd delegate
        all gRPC interactions to another object. Let's call this another object Foo. Foo could then
        have a nice clear API which clearly expresses if a gRPC interaction is a unary RPC,
        client-server stream RPC or server-client stream RPC. Foo would become the client-side
        mapping to server-side ptyHostService, perhaps it could actually have a name similar to
        ptyHostClient?
        * Examples:
          * Foo.getCwd(ptyId) – doesn't accept stream, is a unary RPC.
          * Foo.onOpen(stream) – accepts stream, name starts with `on`, is a server-client stream RPC.
          * Foo.resize(stream) – accepts stream, name doesn't start with `on`, is a client-server
            stream RPC.
        * Benefits of this approach:
          * PtyProcess on client doesn't have to deal with gRPC quirks like `writeOrThrow`,
            doesn't have to interact with gRPC stuff directly which has a very non-idiomatic API.
          * You could open Foo on one side of your editor and PtyEventsStreamHandler/PtyHostService
            on the other and clearly see the mapping between them.
        * Cons:
          * Another layer of indirection.
        * Alternatives:
          * Organize createPtyProcessClient better.
            * createPtyProcessClient would still need to deal with non-idiomatic gRPC API, stream
              specific stuff.
